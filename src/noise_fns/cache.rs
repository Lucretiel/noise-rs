use math::{Point2, Point3, Point4};
use noise_fns::NoiseFn;
use std::cell::Cell;

#[derive(Clone, Debug, Copy)]
struct CachedValue<K> {
    key: K,
    value: f64,
}

/// Noise function that caches the last output value generated by the source
/// function.
///
/// If the input coordinates passed to `Cache::get` are equal to the previous
/// call, the function returns the cached result of the previous call to
/// `Source::get`. Otherwise, `Source::get` is called with the new coordinates,
/// overwriting the cache with the result, and returning the result to the
/// caller.
///
/// Caching a noise function is useful if it is used as a source function for
/// multiple noise functions. If a source function is not cached, the source
/// function will redundantly calculate the same output value once for each
/// noise function in which it is included.
#[derive(Clone, Debug, Default)]
pub struct Cache<Source> {
    /// Outputs the value to be cached.
    pub source: Source,

    value2: Cell<Option<CachedValue<Point2<f64>>>>,
    value3: Cell<Option<CachedValue<Point3<f64>>>>,
    value4: Cell<Option<CachedValue<Point4<f64>>>>,
}

impl<Source> Cache<Source> {
    pub fn new(source: Source) -> Self {
        Cache {
            source,
            value2: Cell::new(None),
            value3: Cell::new(None),
            value4: Cell::new(None),
        }
    }
}

macro_rules! impl_cache {
    (for $Type:ty => $value:ident) => {
        impl<Source: NoiseFn<$Type>> NoiseFn<$Type> for Cache<Source> {
            fn get(&self, point: $Type) -> f64 {
                match self.$value.get() {
                    Some(CachedValue { key, value }) if key == point => value,
                    _ => {
                        let value = self.source.get(point);
                        self.$value.set(Some(CachedValue { key: point, value }));
                        value
                    },
                }
            }
        }
    };
}

impl_cache! {for Point2<f64> => value2}
impl_cache! {for Point3<f64> => value3}
impl_cache! {for Point4<f64> => value4}
